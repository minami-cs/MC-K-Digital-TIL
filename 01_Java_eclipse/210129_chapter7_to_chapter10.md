# 💡 상속 (이어서)

## 4. 추상 클래스

* 추상 클래스는 실체 클래스들의 공통되는 필드와 메소드를 정의한 클래스이다.
* 실체 클래스의 부모 클래스 역할을 하기 때문에 new연산자를 사용해서 객체를 직접 생성하지 못하고 상속으로 자식 클래스만 생성할 수 있다.
* 추상 클래스는 `abstract`를 붙여서 클래스를 선언한다.

```java
// 추상 클래스 선언
public abstract class 클래스 {
    필드;
    생성자;
    메소드;
}
```

### 추상 클래스의 용도

* 실체 클래스의 공통 필드와 메소드 이름 통일
  * 여러 개발자가 한 클래스를 사용하면 각각 다른 이름을 사용할 수 있는데 하나로 통일해서 사용하도록 할 수 있다.
* 실체 클래스 작성 시간 절약
  * 공통적인 필드와 메소드를 추상 클래스에 선언하고 실체 클래스마다 다르게 사용해야 하는 것만 따로 선언하면 시간이 절약된다.
* 실체 클래스 설계 규격을 만들고자 할 때
  * 여러 개의 클래스를 만들어야 할 때 동일한 필드와 메소드는 추상 클래스로 하는 설계 규격을 만드는 것이 좋다.

### 추상 메소드와 오버라이드

* 추상 메소드는 추상 클래스를 선언할 때처럼 `abstract`를 붙여서 선언한다.
* 추상 메소드에는 실행문이 담긴 중괄호(`{}`)가 없다.
* 추상 클래스를 단순히 상속만 받으려면 자식 클래스도 추상 클래스가 되어야 하지만, 추상 클래스 내부에 선언한 추상 메소드를 자식 클래스에서 **오버라이드**하면 자식 클래스는 실체 클래스로서 부모인 추상 클래스의 메소드를 상속받아 구현하여 사용할 수 있다.

```java
// 추상 클래스 예제
abstract class MyObject {
	int n;
	public void method1() {}
	public abstract void method2();
}

class YourObject extends MyObject {  // 추상 클래스를 상속받으려면 자식 클래스도 추상 클래스여야 한다.
// 그러나 자식 클래스를 추상 클래스로 하지 않으려면 추상메소드를 override해서 구현해야 한다.
	@Override
	public void method2() {
	}  
}

public class AbstractExample {
	public static void main(String[] args) {
//		MyObject mo = new MyObject();  // 추상 클래스는 인스턴스화(객체화) 불가능
		YourObject yo = new YourObject();  // 상속받아서 추상메소드를 구현한 클래스는 인스턴스화 가능
	}
}
```

# 💡 인터페이스

## 1. 인터페이스의 역할

### 인터페이스?

* 개발자들 사이에서 주고받는 약속으로 사용자 인터페이스를 말하는 것이 아니다!
* 개발 코드와 객체가 서로 통신하는 접점이며, 개발 코드를 몰라도 인터페이스의 메소드만 알면 🆗
* 인터페이스는 한 번에 여러 개를 상속받아 사용할 수 있다.

### 인터페이스의 역할

1. 개발 코드가 객체에 종속되지 않게 해주어서 객체를 쉽게 교체 가능하게 해준다.
2. 개발 코드를 변경하지 않아도 리턴값이나 실행 내용이 다양해질 수 있다. ➡ *다형성 구현!*

## 2. 인터페이스 선언

> **이클립스에서 인터페이스 생성 방법**
>
> 👉 `File` ➡ `New` ➡ `Interface`

* 인터페이스는 무조건 public으로 자동 생성된다!

```java
public interface 인터페이스명 {
    // 상수
    타입 상수명 = 값;
    // 추상 메소드
    타입 메소드명(매개변수, ...);
    // 디폴트 메소드
    default 타입 메소드명(매개변수, ...) {...}
    // 정적 메소드
    static 타입 메소드명(매개변수) {...}
}
```

### 상수 필드

* 인터페이스는 필드 중에서 **상수 필드**만 선언 가능
* 인터페이스 내에 선언한 필드는 모두 자동으로 `public static final`로 생성
* 반드시 선언과 동시에 초기값 지정
* 상수명 선언 규칙
  * 모두 대문자로 작성
  * 여러 단어로 구성된 경우에는 언더바(`_`)로 단어 연결

## 3. 인터페이스 구현

### 3-1. 구현 클래스

#### 구현 클래스 생성

**📌 방법1. 클래스 생성 시 인터페이스 추가**

![](C:%5CUsers%5CUser%5CDesktop%5CTIL%5Cmd-img/g.png)

**📌 방법2. 이미 생성한 클래스의 이름 뒤에 `implements`를 써서 인터페이스 추가**

```java
public class 구현클래스명 implements 인터페이스명 {
    // 인터페이스의 추상 메소드를 override하여 실체 메소드 선언
}
```

#### 인터페이스의 추상 메소드를 구현 클래스의 실체 메소드로 작성하는 방법

* 실체 메소드의 선언부가 추상 메소드와 정확히 일치해야 한다.
* 인터페이스의 모든 추상 메소드는 기본적으로 `public`이므로 더 낮은 접근 제한으로는 작성 불가
* `public`을 생략하면 컴파일 에러가 난다.
* 구현 클래스에 실체 메소드를 작성하지 않으면 구현 클래스가 자동으로 추상 클래스가 되어서 클래스 앞에 `abstract`를 작성해야 한다.
* 앞서 추상 클래스의 추상 메소드를 실체 메소드로 구현하는 것과 같은 방법으로 `Override`를 이용하여 인터페이스의 추상 메소드를 실체 메소드로 구현하면 된다.

> **예제**
>
> ```java
> public interface MessageBean {
> 	public void sayHello(String name);  // interface의 추상 메소드
> }
> ```
>
> ```java
> public class MessageBeanKr implements MessageBean {
> 	@Override
> 	public void sayHello(String name) {
> 		System.out.println("안녕하세요, " + name + "님!");	
> 	}
> }
> ```
>
> ```java
> public class MessageBeenEn implements MessageBean {
> 	@Override
> 	public void sayHello(String name) {
> 		System.out.println("Hello, " + name + "!");
> 	}
> }
> ```