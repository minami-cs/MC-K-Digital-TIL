# 💡 클래스 - 복습

## 1. 클래스의 또 다른 정의

### 클래스는 데이터와 함수의 결합이다!

* 변수: 하나의 데이터를 저장할 수 있는 공간
* 배열: 같은 타입의 여러 데이터를 저장할 수 있는 공간
* 구조체: 타입에 관계없이 서로 관련된 데이터를 저장할 수 있는 공간 (➡ C++에서 나온 개념)
* 클래스: 데이터와 함수의 결합 (구조체+함수)

### 클래스 사용자 정의 타입(User-defined type)

- 프로그래머가 직접 새로운 타입을 정의할 수 있다.
- 서로 관련된 값을 묶어서 하나의 타입으로 정의

```java
class Time {
    int hour;
    int minute;
    int second;
    
    //int[] hour = new int[3];
    //int[] minute = new int[3];
    //int[] second = new int[3];
    //위는 아래처럼 쓸 수 있다.
    Time[] t = new Time[3];
    t[0] = new Time();
    t[1] = new Time();
    t[2] = new Time();
}
```

## 2. 변수와 메소드

### 2-1. 선언위치에 따른 변수의 종류

> 변수의 선언위치가 변수의 종류와 범위(scope)를 결정

- 클래스 변수와 인스턴스 변수는 클래스 영역에 선언된다.

#### 클래스 변수

- 클래스 변수는 클래스가 메모리에 올라갈 때 생성되고, 클래스 변수의 데이터는 힙(heap) 영역에 저장된다.
- 클래스 변수는 인스턴스 생성없이 '클래스이름.클래스변수명'으로 접근
- static변수(클래스 변수)는 프로그램 종료시까지 사용 가능

#### 인스턴스 변수

- 인스턴스 변수는 인스턴스 생성 시에 생성된다.
- 참조변수가 없을 때에는 가비지 컬렉터가 자동으로 제거

#### 지역 변수

- 메소드 영역에 선언되는 변수
- JVM이 해당 메소드를 실행할 때 메소드 영역에 생성된다.

**📌 클래스는 메소드 영역에, 함수는 스택 영역에, 데이터는 힙 영역에 저장된다!**

### 2-2. 메소드

> 작업을 수행하기 위한 명령문의 집합으로 어떤 값을 입력받아서 처리하고 그 결과를 돌려준다. (a.k.a. 함수)

#### 메소드 선언 방법

```java
리턴타입 메소드명 ([매개변수선언, ...]) {
    실행할 코드 작성
}
```

- 리턴값이 없는 메소드는 리턴타입 대신 `void`를 사용

  ```java
  // 예제
  void power() {
      power = !power
  }
  ```

#### return문

> 메소드 실행을 중지하고 리턴값을 지정하는 역할

- 리턴값이 있는 메소드

  - 반드시 리턴문을 사용해서 리턴값을 지정해야 한다.

  - 리턴문의 갯수는 최소화하는 것이 좋다.

📌 **유의:** `exit`는 프로그램 실행을 끝낸다는 뜻! 리턴문과 헷갈리지 말자!

#### 메소드의 호출

- 메소드는 클래스 내부 또는 외부의 호출로 실행된다.

  - 클래스 내부: 메소드 이름으로 호출
  - 클래스 외부: 객체 생성 후 참조 변수를 이용하여 호출

- 메소드에 선언된 매개변수가 없는 경우

  ```java
  참조변수.메소드명();
  ```

- 메소드에 선언된 매개변수가 있는 경우

  ```java
  참조변수.메소드명(값1, 값2, ...);
  ```

#### 메소드 오버로딩(Overloading)

> 하나의 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것

- 하나의 메소드 이름으로 다양한 매개값을 받기 위해 오버로딩을 이용한다.
- 오버로딩의 조건
  - 메소드 이름이 같아야 한다.
  - 매개변수의 타입 or 갯수 or 순서는 달라야 한다.
  - 리턴타입은 오버로딩 구현에 아무런 영향을 주지 않는다.

### 2-3. JVM의 메모리 구조

- JVM의 메모리 구조는 메소드 영역, 호출스택, 힙으로 구성된다.

#### 호출스택

- 특징

  1. 메소드가 호출되면 수행에 필요한 메모리를 스택에 할당받는다.

  2. 수행을 마치면 사용했던 메모리를 반환한다.

  3. 호출스택의 제일 위에 있는 메소드가 현재 사용 중인 메소드이다.

  4. 아래에 있는 메소드는 바로 위의 메소드를 호출한 메소드이다.

  5. 호출하는 순서대로 위로 차곡차곡 쌓이고, 사용이 끝나는대로 위에서부터 하나씩 메모리를 반환한다.

     ```java
     // 스택 예시
     		3
     	2	2	2
     1	1	1	1	1
     ```

## 3. 생성자

> 인스턴스가 생성될 때마다 호출되는 **인스턴스 초기화 메소드**
>
> - 인스턴스 초기화: 인스턴스 변수에 적절한 값을 저장하는 것

- 함수와 똑같이 생겼으며, `new` 연산자를 사용한다.
- 몇 가지 조건을 제외하고 메소드와 같다.
  - 리턴타입 없이 `void` 사용🙅‍♀️
  - 생성자 이름은 클래스 이름과 같아야 한다.

### 3-1. 기본 생성자

- 매개변수가 없는 생성자를 기본 생성자라고 한다.

- 클래스에 생성자가 하나도 없으면 컴파일러가 기본 생성자를 추가한다.

  ```java
  // 컴파일러가 추가한 기본 생성자는 내용이 없다.
  Card() {}
  ```

**📌 모든 클래스에는 반드시 하나 이상의 생성자가 있어야 한다!**

### 3-2. 매개변수가 있는 생성자

- 매개변수가 있는 생성자는 간략하게 쓴다.

  ```java
  Car c = new Car("white", "auto", 4);
  ```

### 3-3. 생성자에서 다른 생성자 호출하기: this()

- `this()`: 생성자와 같은 클래스의 다른 생성자를 호출할 때 사용

  - 특징: 다른 생성자 호출은 생성자의 첫 문장에서만 가능하며, 부모 생성자인 `super()`도 마찬가지이다.

  ```java
  class Car {
      String color;
      String gearType;
      int door;
      
      //코드의 재사용성을 높인 코드
      Car() {
          door = 5;
          this("white", "auto", 4);
      }
  ```

### 3-4. 참조변수 this

- `this`: 인스턴스 자신을 가리키는 참조변수

  - 특징
    - 인스턴스의 주소가 저장되어 있고, 모든 인스턴스 메소드에 지역변수로 숨겨진 채 존재한다.
    - 가장 가까운 지역메소드의 지역변수를 참조한다.

  ```java
  //인스턴스변수와 지역변수를 구별하기 위해 참조변수 this사용
  Car(String color, String gearType, int door) {
      this.color = color;
      this.gearType = gearType;
      this.door = door;
  }
  ```

### 3-4. 생성자를 이용한 인스턴스의 복사

- 인스턴스간의 차이는 인스턴스 변수의 값뿐이고 나머지는 동일하다.
- 생성자에서 참조변수를 매개변수로 받아서 인스턴스변수들 값을 복사한다.
- 똑같은 속성값을 갖는 독립적인 인스턴스가 하나 더 만들어진다.

## 4. 변수의 초기화

> 변수를 선언하고 처음으로 값을 저장하는 것을 의미한다.

- 자바의 변수 종류 3가지
  1. 지역변수
  2. static 변수
  3. 인스턴스변수

### 4-1. 특징

- 멤버변수(인스턴스변수, 클래스변수)와 배열은 각 타입의 기본값으로 자동초기화되므로 초기화 생략 가능!
- 타입이 다른 변수는 함께 선언하거나 초기화🙅‍♀️
- 타입이 같은 변수는 콤마를 사용해서 함께 선언하거나 초기화🙆‍♀️

### 4-2. 멤버변수의 초기화 방법

#### 1. 명시적 초기화
```java
class Car {
	int door = 4;		//기본형 변수의 초기화
	Engine e = new Engin();	//참조형 변수의 초기화
}
```
#### 2. 생성자
```java
Car(String color, String gearType, int door) {
    this.color = color;
    this.gearType = gearType;
    this.door = door;
}
```
#### 3. 초기화 블럭

- 인스턴스 초기화 블럭: `{}`
  - 생성자에서 공통적으로 수행되는 작업에 사용되며 인스턴스가 생성될 때마다 생성자보다 먼저 실행
- 클래스 초기화 블럭: `static {}`
  - 클래스변수의 복잡한 초기화에 사용되며 클래스가 로딩될 때 실행

### 4-3. 멤버변수의 초기화 시기와 순서

- 클래스변수 초기화 시점: 클래스가 처음 로딩될 때 단 한 번
- 인스턴스변수 초기화 시점: 인스턴스가 생성될 때 마다

```java
// 유일한 값을 가지는 객체들이 공유할 때가 있다면
class Product {
	static int count = 100;
	int serialNo;
	
	public Product() {
		serialNo = count++;
		//serialNo = ++count;  // 101부터 카운트할 경우
	}
}
public class ProductTest {

	public static void main(String[] args) {
		Product p1 = new Product();
		Product p2 = new Product();
		Product p3 = new Product();
		
		System.out.println(p1.serialNo);
		System.out.println(p2.serialNo);
		System.out.println(p3.serialNo);
	}
}
```

# 💡 상속 - 복습

## 1. 상속의 정의

- 상속은 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 상속을 하려면 `extends`를 쓴다.
- 상속은 **단 하나만** 가능!!

## 2. 클래스간의 관계

### 상속관계

- 공통되는 부분은 조상이 관리하고 개별적인 부분은 자손에서 관리
- 조상이 변경되면 자손에 영향을 미치지만, 자손은 변경되어도 조상에 아무런 영향을 미치지 않는다.

### 포함관계

- **포함**이란?

  👉 한 클래스의 멤버변수로 다른 클래스를 선언하는 것

- 작은 단위의 클래스를 먼저 만들고 이들을 조합해서 하나의 커다란 클래스를 만들면 큰 클래스가 작은 클래스를 포함하는 관계가 된다.

### 관계 결정하기

- 가능한 한 많은 관계를 맺어주어 재사용성을 높이고 관리하기 쉽게 한다.
- `is-a`와 `has-a`를 가지고 문장을 만들어 본다.
- **Java는 단일상속만 허용한다.**

## 3. 오버라이딩(Overriding)

> 조상클래스에서 상속받은 메소드의 내용을 상속받는 클래스에 맞게 변경하는 것

### 3-1. 오버라이딩의 조건

- 선언부(이름, 매개변수, 리턴타입)가 같아야 한다.
- 접근제어자를 더 좁은 범위로 변경할 수 없다.
  - 예: 조상메소드가 `protected`일 때, 자식은 `protected` 또는 `public`으로만 변경 가능
- 조상클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

### 3-2. super 참조변수

- `this`: 인스턴스 자신을 가리키는 참조변수
- `super`: `this`와 같다. 부모 것을 가리키는 참조변수
- `super()`: 조상의 생성자

```java
class Point {
	int x, y;
	Point() {}
	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
	String getLocation() {
		return "x: " + x + ", y: " + y;
	}
}
class Point3D extends Point {
	int z;
	Point3D(int x, int y, int z) {
		super(x, y);
//		this.x = x;
//		this.y = y;
		this.z = z;
	}
	@Override
	String getLocation() {
		return super.getLocation() + ", z: " + z;  // 부모 것 + 자식 것
	}
}
public class OverrideTest {
	public static void main(String[] args) {
		Point3D p1 = new Point3D(1,2,3);
		System.out.println(p1.getLocation());

	}
}
```

## 4. 패키지

> 클래스 모음집

- 다른 패키지의 클래스를 사용하려면 다른 패키지를 `import`해야 한다.
  - 자동 import 단축키: `ctrl + shift + o`
- 다른 패키지의 함수를 사용하려면 getter와 setter를 이용
  - Source ➡ Generate Getters and Setters
- 패키지명은 보통 소문자로 명명한다.

### 4-1. 패키지의 선언

- 패키지는 소스파일에 첫 번째 문장(주석 제외)으로 선언
- 패키지가 선언되지 않은 클래스는 자동으로 이름없는 패키지에 속한다.

### 4-2. import문

- 사용할 클래스가 속한 패키지를 지정할 때 사용
- import문을 사용하면 클래스를 사용할 때 패키지명을 생략할 수 있다.
- `java.lang`패키지의 클래스는 import 없이 사용 가능하다.

### 4-3. import문의 선언

- 패키지 내부에 다른 패키지가 있을 때 바깥 패키지를 import해도 내부 패키지까지 import되지는 않는다. import는 클래스만 가져오는 것이기 때문.
- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여야 한다.

```java
package sec01.var.pac;

public class PacClass {
}
```

```java
package sec01.var;  // 자바 파일 최상단에는 패키지 이름이 단 한 번만 선언된다

import sec01.var.pac.PacClass;

public class PacTest {
	public static void main(String[] args) {
		// sec01.var.pac.PacClass pc = new sec01.var.pac.PacClass();
		PacClass pc = new PacClass();  // import를 통해 클래스만 사용가능
	}
}
```

